# **设计模式是什么？**

设计模式是软件设计中常见问题的典型解决方案。 每个模式就像一张蓝图， 你可以通过对其进行定制来解决代码中的特定设计问题。

设计模式与方法或库的使用方式不同， 你很难直接在自己的程序中套用某个设计模式。 模式并不是一段特定的代码， 而是解决特定问题的一般性概念。 你可以根据模式来实现符合自己程序实际所需的解决方案。

人们常常会混淆模式和算法， 因为两者在概念上都是已知特定问题的典型解决方案。 但算法总是明确定义达成特定目标所需的一系列步骤， 而模式则是对解决方案的更高层次描述。 同一模式在两个不同程序中的实现代码可能会不一样。

算法更像是菜谱： 提供达成目标的明确步骤。 而模式更像是蓝图： 你可以看到最终的结果和模式的功能， 但需要自己确定实现步骤。

设计模式是软件设计中常见问题的典型解决方案。 每个模式就像一张蓝图， 你可以通过对其进行定制来解决代码中的特定设计问题。



**模式包含哪些内容？**

大部分模式都有正规的描述方式，以便在不同情况下使用。描述包括以下部分：

​                ● 意图——简单描述问题和解决方案

​                ● 动机——进一步解释问题并说明模式会如何提供解决方案

​                ● 结构——展示模式的每个部分和它们之间的关系 

在不同语言的实现提供流行的代码，以便更好理解模式背后的思想

部分模式还列出一些实用细节，例如模式的适用性、实现步骤以及与其他模式的关系



# **模式的历史**

模式是面向对象设计中常见问题的典型解决方案。 同样的解决方案在各种项目中得到了反复使用， 所以最终有人给它们起了名字， 并对其进行了详细描述。 这基本上就是模式被发现的历程了。

模式的概念是由克里斯托佛·亚历山大在其著作 《建筑模式语言》 中首次提出的。 本书介绍了城市设计的 “语言”， 而此类 “语言” 的基本单元就是模式。 模式中可能会包含对窗户应该在多高、 一座建筑应该有多少层以及一片街区应该有多大面积的植被等信息的描述。



# **为什么以及如何学习设计模式？**

你可能也在不自知的情况下已经使用过一些设计模式了。 所以为什么不花些时间来更进一步学习它们呢？

设计模式是针对软件设计中常见问题的工具箱，其中的工具就是各种经过实践验证的解决方案。即使你从未遇到过这些问题，了解模式仍然非常有用，因为它能指导你如何使用面向对象的设计原则来解决问题。

设计模式定义了一种让你和团队成员能够更高效沟通的通用语言。“这里用单例就可以了”，所有人都会理解这条建议背后的想法。知晓模式及其名称，就无须解释什么是单例。



# **关于模式的争议**

 ● **一种针对不完善编程语言的蹩脚解决方案**

通常当所选编程语言或技术缺少必要的抽象功能时， 人们才需要设计模式。 在这种情况下， 模式是一种可为语言提供更优功能的蹩脚解决方案。

例如， 策略模式在绝大部分现代编程语言中可以简单地使用匿名 （lambda） 函数来实现。

● **低效的解决方案**

模式试图将已经广泛使用的方式系统化。许多人会将这样的统一化认为是教条，“全心全意”实施这样的模式，而不会根据项目的实际情况对其进行调整

● **不当使用**

“如果你只有一把铁锤，那么任何东西看上去都像是钉子。”



# **设计模式分类**

不同设计模式在其复杂程度、 细节层次以及应用范围等方面各不相同。类比于道路的建造： 如果你希望让十字路口更加安全， 那么可以安装一些交通信号灯， 或者修建包含行人地下通道在内的多层互通式立交桥。

最基础的、底层的模式通常被称为惯用技巧。这类模式一般只能在一种编程语言中使用。

最通用、高层的模式是架构模式。可以在任何语言中使用这类模式。与其他模式不同，他们可用于整个应用程序的架构设计。

此外， 可以根据模式的目的来将它们划分为三个不同的模式类别：

● 创建型模式——提供创建对象的机制，增加已有代码的灵活性和可复用性

● 结构型模式——介绍如何将对象和类组装成较大的结构，同时保持结构的灵活高效

● 行为模式——负责对象间的高效沟通和职责委派 



# **面向对象程序设计简介**

成员变量和方法可以统称为类的成员。存储在对象成员变量中的数据通常称为状态，对象中的所有方法则定义了其行为。



# **面向对象程序设计基础**

**抽象**

使用面向对象程序设计理念开发程序时，大部分时间用于根据真实世界对象来设计程序中的对象。程序中的对象并不需要能够百分百准确反映其原型。实际只需模拟真实对象的特性属性和行为即可。



**封装**

封装指一个对象对其他对象隐藏其部分状态和行为，而仅向程序其他部分暴露有限的接口的能力。

绝大部分编程语言的接口和抽象类（或方法）都基于抽象和封装的概念。接口机制（interface或protocol关键字来声明）允许你定义对象之间的协议。这也是接口仅关心对象行为，以及你不能在接口中声明成员变量的原因之一。



FlyingTransport 接口中有一个fly(origin, destination, passengers) 方法

在设计航空运输模拟器时，可以对 Airport 类做出限制，使其仅与实现了 FlyingTransport 接口的对象进行交互。此后，可以确保传递给机场对象的任何对象都能到达或离开这种类型的机场。

可以任何方式更改这些类中fly方法的实现方式。只要方法签名与接口中的声明保持一致，那么所有机场类的实例都能与飞行对象进行交互。



```
AirPort
+accept(vehicle:FlyingTransport)

interface FlyingTransport
+fly(origin, destination, passengers)

Helicopter implements FlyingTansport
+fly(...)

Airplane implements FlyingTansport
+fly(...)
```



**继承**

继承最主要的好处是代码复用。

使用继承后，子类将拥有与父类相同的接口。如果父类中声明了某个方法，你将无法在子类中隐藏该方法。还必须实现所有的抽象方法，即使它们对子类没有意义。

在绝大多数语言中，子类仅能对一个父类进行扩展。另一方面，任何类都可以同时实现多个接口。但是如果父类实现了某个接口，那么其所有子类必须实现该接口。



**多态**

```
abs:Animal
+abs:makeSound()

cat extend Animal
+makeSound()

Dog extend Animal
+makeSound()


bag = [new Cat(), new Dog()];
foreach (Animal a : bag)
    a.makeSound()
```



程序并不知道 a 变量中所包含的对象的具体类型，但幸亏有被称为多态的特殊机制，程序可以追踪子类并调用其方法，从而执行恰当的行为。

**多态是指程序能够检测对象所属的实际类，并在当前上下文不知道其真实类型的情况下调用其实现的能力。**

还可以将多态看作是一个对象“假扮”为其他东西（通常是其扩展类或实现的接口）的能力。袋中的猫和狗就相当于假扮成了一般的动物。



# **对象之间的关系**

除了继承和实现之外，对象之间还有其他关系。



**依赖**

```
// UML 依赖：教授依赖于课程资料
教授 ---> 课程
```

依赖是类之间最基础、最微弱的关系类型。如果一个类的定义可能会造成另一个类的变化，那么这两个类之间就存在依赖关系。代码中使用具体类的名称时，通常意味着存在依赖关系。例如：在指定方法签名类型时，或是通过调用构造函数对对象进行初始化时等。通过让代码依赖接口或抽象类（而不是具体类），可以降低其依赖程度。

UML图不会展示所有依赖——在代码中的数量太多了。为了不让依赖关系破坏UML图，必须对其进行精心选择，仅展示那些对于沟通你的想法来说重要的依赖关系。



**关联**

```
// UML 关联：教授
教授 ————> 学生
```

关联是一个对象使用另一对象或与另一对象进行交互的关系。双向关联也是正常的，用双向箭头表示。关联是一种特殊的依赖，即一个对象总有拥有访问与其交互的对象的权限，而简单的依赖关系并不会在对象间建立永久性的联系。

一般可以使用关联关系表示类似于成员变量的东西。这种关系将一直存在，总能通过 “订单” 来获取其 “顾客”。但是它并非一定是成员变量。如果根据接口来创建类，它可以表示一个可返回 “订单” 的 “顾客”。

```
class Professor is
    field Student student
    // ...
    method teach(Course c)
        // ...
        this.student.remember(c.getKnowledge())
```

teach 方法接受一个来自 Course 类的参数。如果修改了 Course 类的 getKnowledge 方法（修改方法名或添加必须的参数），代码将崩溃，这是依赖关系。

Student 类是 Professor 类的依赖：如果 remember 方法被修改，Professor 的代码也将崩溃。但由于 Professor 的所有方法总能访问 student 成员变量，所以 Student 类不仅是依赖，还是关联。



**聚合**

```
// UML 聚合：院系包含教授
院系 ◇————> 教授
```

聚合是一种特殊的关联，用于表示多个对象之间的 “一对多”、“多对多” 或 “整体对部分” 的关系。普通关联仅用于描述两个对象之间的关系。在聚合关系中，一个对象 “拥有” 一组其他对象，并扮演着容器或集合的角色。组件可以独立于容器存在，也可以同时连接多个容器。UML 中聚合关系使用一端是空心菱形，另一端指向组件的箭头表示。

UML 图表示的是类之间的关系。意味着大学可能由多个院系构成，可以使用 UML 符号在关系的两端表明数量，但如果可从上下文明确数量的话，可以省略标注。



**组合**

```
// UML 组合：大学由院系构成
大学 ◆————> 院系
```

组合是一种特殊的聚合，其中一个对象由一个或多个其他对象实例构成。组合与其他关系的区别在于组件仅能作为容器的一部分存在。

许多人在实际想说聚合和组合时使用 “组合” 这个术语。最恶名昭彰的例子 “组合优于继承” 原则。并不是因为不清楚它们之间的差别，而是 “组合” 说起来更顺口。



**实现**

```
// UML 实现：Airplane 实现 FlyingTransport 接口
Airplane ---▷ FlyingTransport
```



**继承**

```
// UML 继承：Cat 继承 Animal
Cat ————▷ Animal
```



**总结**

![img](https://docimg4.docs.qq.com/image/AgAACOA3X38S6O1DwP9PNJu5s0cgD3Cz.png?w=1298&h=1147)

● 依赖：对类 B 进行修改会影响到类 A

● 关联：对象 A 知道对象 B。类 A 依赖于类 B

● 聚合：对象 A 知道对象 B 且由 B构成。类 A 依赖于类 B

● 组合：对象 A 知道对象 B、由 B 构成而且管理着 B 的生命周期。类 A 依赖于类 B

● 实现：类 A 定义的方法由接口 B 声明。对象 A 可被视为对象 B。类 A 依赖于类 B

● 继承 ：类 A 继承类 B 的接口和实现，但是可以对其进行扩展。对象 A 可被视为对象 B。类 A 依赖于类 B