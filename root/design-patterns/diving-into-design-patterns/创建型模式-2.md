# **生成器**

建造者模式、Builder

使你能够分步骤创建复杂对象。该模式允许你使用相同的创建代码生成不同类型和形式的对象。



## 问题

假设有一个复杂对象，在对其进行构造时需要对诸多成员变量和嵌套对象进行繁复的初始化工作。这些初始化代码深藏于一个包含众多参数且让人看不懂的构造函数中；甚至还有更糟糕的情况，就是这些代码散落在客户端代码的多个位置。

例如，如何创建一个房屋 House 对象。建造一栋简单的房屋，首先需要建造四面墙和地板，安装房门和一套窗户，然后再建造一个屋顶。但是如果想要一栋更宽敞明亮的房屋，还要有院子和其他设施（例如暖气、排水和供电设备），那又该怎么办呢？

最简单的方法是扩展房屋基类，然后创建一系列涵盖所有参数组合的子类。但最终你将面对相当数量的子类，任何新增的参数（例如门廊类型）都会让这个层次结构更加复杂。如果为每种可能的对象都创建一个子类，这可能导致程序变得过于复杂。

另一种方法则无需生成子类。你可以在房屋基类中创建一个包括所有可能参数的超级构造函数，并用它来控制房屋对象。这种方法确实可以避免生成子类，但它会造成另一个问题。拥有大量输入参数的构造函数也有缺陷：这些参数也不是每次都要全部用上的。通常情况下，绝大部分的参数没有使用，这使得对于构造函数的调用十分不简洁。例如：只有很少的房子有游泳池，因此与游泳池相关的参数十之八九是没用的。



## 解决方案

生成器模式建议将对象构造代码从产品类中抽取出来，并将其放在一个名为生成器的独立对象中。

```
// 生成器模式让你能够分步骤创建复杂对象。生成器不允许其他对象访问正在创建中的产品。
HouseBuilder
...
+ buildWalls()
+ buildDoors()
+ buildWindows()
+ buildRoof()
+ buildGarage()
+ getResult():Housr
```

该模式会将对象构造过程划分为一组步骤，比如 buildWalls 创建墙壁和 buildDoor 创建房门等。每次创建对象时，你都需要通过生成器对象执行一系列步骤。重点在于你无需调用所有步骤，而只需调用创建特定对象配置所需的那些步骤即可。

当你需要创建不同形式的产品时，其中的一些构造步骤可能需要不同的实现。例如，木屋的房门需要使用木头制造，而城堡的房门则必须使用石头制造。在这种情况下，你可以创建多个不同的生成器，用不同方式实现一组相同的创建步骤。然后你就可以在创建过程中使用这些生成器（例如按顺序调用多个构造步骤）来生成不同类型的对象。

不同生成器以不同方式执行相同的任务。例如，第一个建造者使用木头和玻璃制造房屋，第二个建造者使用石头和钢铁，而第三个建造者使用黄金和钻石。在调用同一组步骤后，三个建造者分别会给你一栋普通房屋、一座小城堡、一座宫殿。但是，只有在调用构造步骤的客户端代码可以通过接口与建造者进行交互时，这样的调用才能返回需要的房屋。



**主管** Director

你可以进一步将用于创建产品的一系列生成器步骤调用抽取成为单独的主管类。主管类可定义创建步骤的执行顺序，而生成器则提供这些步骤的实现。主管知道需要哪些创建步骤才能获得可正常使用的产品。

严格来说，你的程序中并不一定需要主管类。客户端代码可直接以特定顺序调用创建步骤。不过，主管类中非常适合放入各种例行构造流程，以便在程序中反复使用。此外，对于客户端代码来说，主管类完全隐藏了产品构造细节。客户端只需要将一个生成器与主管类关联，然后使用主管类来构造产品，就能从生成器处获得构造结果了。



## 结构

![image-20230219101813404](../../../../../blog/lucashelbyxx.github.io/images/image-20230219101813404.png)

1. 生成器（Builder）接口声明在所有类型生成器中通用的产品构造步骤。
2. 具体生成器（Concrete Builders）提供构造过程的不同实现。具体生成器也可以构造不遵循通用接口的产品。
3. 产品（Products）是最终生成的对象。由不同生成器构造的产品无需属于同一类层次结构或接口。
4. 主管（Director）类定义调用构造步骤的顺序，这样你就可以创建和复用特定的产品配置。
5. 客户端（Client）必须将某个生成器对象与主管类关联。一般情况下，你只需通过主管类构造函数的参数进行一次性关联即可。此后主管类就能使用生成器对象完成后续所有的构造任务。但在客户端将生成器对象传递给主管类制造方法时还有另一种方式。在这种情况下，你在使用主管类生产产品时每次都可以使用不同的生成器。



## 伪代码

![image-20230219103927079](../../../../../blog/lucashelbyxx.github.io/images/image-20230219103927079.png)

关于生成器模式的例子演示了你可以如何复用相同的对象构造代码来生成不同类型的产品。例如汽车 Car 及其相应的使用手册 Manual。

汽车是一个复杂对象，有数百种不同的制造方法。我们没有在汽车类中塞入一个巨型构造函数，而是将汽车组装代码抽取到单独的汽车生成器类中。该类中有一组方法可用来配置汽车的各种部件。如果客户端代码需要组装一辆与众不同、精心调教的汽车，它可以直接调用生成器。或者，客户端可以将组装工作委托给主管类，因为主管类知道如何使用生成器制造最受欢迎的几种型号汽车。

使用手册会介绍汽车的每一项功能，因此不同型号的汽车，其使用手册内容也不一样。因此，你可以复用现有流程来制造实际的汽车及其对应的手册。当然，编写手册和制造汽车不是一回事，所以我们需要另外一个生成器对象来专门编写使用手册。该类与其制造汽车的兄弟类都实现了相同的制造方法，但是其功能不是制造汽车，而是描述每个部件。将这些生成器传递给相同的主管对象，我们就能够生成一辆汽车或一本使用手册了。

最后一个部分是获取结果对象。尽管金属汽车和纸质手册存在关联，但它们却是完全不同的东西。我们无法在主管类和具体产品类不发生耦合的情况下，在主管类中提供获取结果对象的方法。因此，我们只能通过负责制造过程的生成器来获取结果对象。

```
// 只有当产品较为复杂且需要详细配置时，使用生成器模式才有意义。下面的两个
// 产品尽管没有同样的接口，但却相互关联。
class Car is
	// 一辆汽车可能配备有 GPS 设备、行车电脑和几个座位。不同型号的汽车（
	// 运动型轿车、SUV 和敞篷车）可能会安装或启用不同的功能。

class Manual is
	// 用户使用手册应该根据汽车配置进行编制，并介绍汽车的所有功能。

// 生成器接口声明了创建产品对象不同部件的方法
interface Builder is
	method reset()
	method setSeats(...)
	method setEngine(...)
	method setTripComputer(...)
	method setGPS(...)

// 具体生成器将遵循生成器接口并提供生成步骤的具体实现。
// 你的程序中可能会有多个以不同方式实现的生成器变体。
class CarBuilder implements Builder is
	private field car:Car
	
	// 一个新的生成器实例必须包含一个在后续组装过程中使用的空产品对象
	constructor CarBuilder() is
		this.reset()
	
	// reset（重置）方法可清除正在生成的对象
	method reset() is
		this.car = new Car()
		
	// 所有生成步骤都会与同一个产品实例进行交互
	method setSeats(...) is
		// 设置汽车座位的数量
		
	method setEngine(...) is
		// 安装指定的引擎
	
	method setTripComputer(...) is
		// 安装行车电脑
	
	method setGPS(...) is
		// 安装 GPS
	
    // 具体生成器需要自行提供获取结果的方法。这是因为不同类型的生成器可能
    // 会创建不遵循相同接口的、完全不同的产品。所以也就无法在生成器接口中
    // 声明这些方法（至少在静态类型的编程语言中是这样的）。
    //
    // 通常在生成器实例将结果返回给客户端后，它们应该做好生成另一个产品的
    // 准备。因此生成器实例通常会在 'getProduct' 方法主体末尾调用重置方法。
    // 但是该行为并不是必需的，你也可让生成器等待客户端明确调用重置方法后
    // 再去处理之前的结果。
	method getProduct():Car is
		product = this.car
		this.reset()
		return product

// 生成器与其他创建型模式的不同之处在于：它让你能创建不遵循相同接口的产品
class CarManualBuilder implements Builder is
	private field manual:Manual
	
	constructor CarManualBuilder() is
		this.reset()
	
	method reset() is
		this.manual = new Manual()
	
	method setSeats(...) is
		// 添加关于汽车座椅功能的文档
	
	method setEngine(...) is
		// 添加关于引擎的介绍
	
	method setTripComputer(...) is
		// 添加关于行车电脑的介绍
	
	method setGPS(...) is
		// 添加关于 GPS 的介绍
	
	method getProduct():Manual is
		// 返回使用手册并重置生成器

// 主管只负责按照特定顺序执行生成步骤。其在根据特定步骤或配置来生成产品时
// 会很有帮助。由于客户端可以直接控制生成器，所以严格意义上来说，主管类并
// 不是必需的。
class Director is
	// 主管可同由客户端代码传递给自身的任何生成器实例进行交互。客户端可通
	// 过这种方式改变最新组装完毕的产品的最终类型。主管可使用同样的生成步
	// 骤创建多个产品变体。
	method constructSportsCar(builder: Builder) is
		builder.reset()
		builder.setSeats(2)
		builder.setEngine(new SportEngine())
		builder.setTripComputer(true)
		builder.setGPS(true)
		
	method constructSUV(builder: Builder) is
		// ...
		
// 客户端代码会创建生成器对象并将其传递给主管，然后执行构造过程。最终结果
// 将需要从生成器对象中获取。
class Application is
	
	method makeCar() is
        director = new Director()

        CarBuilder builder = new CarBuilder()
        director.constructSportsCar(builder)
        Car car = builder.getProduct()

        CarManualBuilder builder = new CarManualBuilder()
        director.constructSportsCar(builder)

        // 最终产品通常需要从生成器对象中获取，因为主管不知晓具体生成器和
        // 产品的存在，也不会对其产生依赖。
        Manual manual = builder.getProduct()
```



## 适用场景

- 使用生成器模式可避免 “重叠构造函数（telescoping constructor)” 的出现。

  假设你的构造函数有十个可选参数，那么调用该函数非常不便；因此，你需要重载这个构造函数，新建几个只有较少参数的简化版。但这些构造函数仍需调用主构造函数，传递一些默认数值来替代省略掉的参数。

  ```
  // 只有在 C# 或 Java 等支持方法重载的编程语言中才能写出如此复杂的构造函数
  class Pizza {
  	Pizza(int size) {...}
  	Pizza(int size, boolean cheese) {...}
  	Pizza(int size, boolean cheese, boolean pepperoni) {...}
  	// ...
  }
  ```

  生成器模式让你可以分步骤生成对象，而且允许你仅使用必须的步骤。应用该模式后，你再也不需要将几十个参数塞进构造函数里了。

- 当你希望使用代码创建不同形式的产品（例如石头或木头房屋）时，可使用生成器模式。

  如果你需要创建的各种形式的产品，它们的制造过程相似且仅有细节上的差异，此时可使用生成器模式。基本生成器接口中定义了所有可能的制造步骤，具体生成器将实现这些步骤来制造特定形式的产品。同时，主管类将负责管理制造步骤的顺序。

- 使用生成器构造组合树或其他复杂对象。

  生成器模式让你能分步骤构造产品。你可以延迟执行某些步骤而不会影响最终产品。你甚至可以递归调用这些步骤，这在创建对象树时非常方便。

  生成器在执行制造步骤时，不能对外发布未完成的产品。这可以避免客户端代码获取到不完整结果对象的情况。



## 实现方式

1. 清晰定义通用步骤，确保它们可以制造所有形式的产品。否则你将无法进一步实施该模式。

2. 在基本生成器接口中声明这些步骤。

3. 为每个形式的产品创建具体生成器类，并实现其构造步骤。

   不要忘记实现获取构造结果对象的方法。你不能在生成器接口中生命该方法，因为不同生成器构造的产品可能没有公共接口，因此你就不知道该方法返回的对象类型。但是，如果所有产品都位于单一类层次中，你就可以安全地在基本接口中添加获取生成对象的方法。

4. 考虑创建主管类。它可以使用同一生成器对象来封装多种构造产品的方式。

5. 客户端代码会同时创建生成器和主管对象。构造开始前，客户端必须将生成器对象传递给主管对象。通常情况下，客户端只需调用主管类构造函数一次即可。主管类使用生成器对象完成后续所有制造任务。还有另一种方式，那就是客户端可以将生成器对象直接传递给主管类的制造方法。

6. 只有在所有产品都遵循相同接口的情况下，构造结果可以直接通过主管类获取。否则，客户端应当通过生成器获取构造结果。



## 优缺点

- 你可以分步创建对象，暂缓创建步骤或递归运行创建步骤。
- 生成不同形式的产品时，你可以复用相同的制造代码。
- 单一职责原则。你可以将复杂构造代码从产品的业务逻辑中分离出来。
- 由于该模式需要新增多个类，因此代码整体复杂程度会有所增加。



## 与其他模式的关系

- 在许多设计工作的初期都会使用工厂方法模式（较为简单， 而且可以更方便地通过子类进行定制），随后演化为使用抽象工厂模式、 原型模式或生成器模式（更灵活但更加复杂）。
- 生成器重点关注如何分步生成复杂对象。抽象工厂专门用于生产一系列相关对象。抽象工厂会马上返回产品，生成器则允许你在获取产品前执行一些额外构造步骤。
- 你可以在创建复杂组合模式树时使用生成器，因为这可使其构造步骤以递归的方式运行。
- 你可以结合使用生成器和桥接模式：主管类负责抽象工作，各种不同的生成器负责实现工作。
- 抽象工厂、生成器和原型都可以用单例模式来实现。



# **原型**

Clone、Prototype

让你能够复制已有对象，而又无需使代码依赖它们所属的类。



## 问题

如果你有一个对象，并希望生成与其完全相同的一个复制品，该如何实现呢？首先，你必须新建一个属于相同类的对象。然后，必须遍历原始对象的所有成员变量，并将成员变量值复制到新对象中。但是有个问题。并非所有对象都能通过这种方式进行复制，因为有些对象可能拥有私有成员变量，它们在对象本身以外是不可见的。“从外部” 复制对象并非总是可行的。

直接复制还有另外一个问题。因为你必须知道对象所属的类才能创建复制品，所以代码必须依赖该类。即使你可以接受额外的依赖性，那还有另外一个问题：有时你只知道对象所实现的接口，而不知道其所属的具体类，比如可向方法的某个参数传入实现了某个接口的任何对象。



## 解决方案

原型模式将克隆过程委派给被克隆的实际对象。模式为所有支持克隆的对象声明了一个通用接口，该接口让你能够克隆对象，同时又无需将代码和对象所属类耦合。通常情况下，这样的接口仅包含一个克隆方法。

所有类对克隆方法的实现都非常相似。该方法会创建一个当前类的对象，然后将原始对象所有的成员变量值复制到新建的类中。你甚至可以复制私有成员变量，因为绝大部分编程语言都允许对象访问其同类对象的私有成员变量。

支持克隆的对象即为原型。当你的对象有几十个成员变量和几百种类型时，对其进行克隆甚至可以代替子类的构造。预生成原型可以代替子类的构造。其运作方式如下：创建一系列不同类型的对象并不同的方式对其进行配置。如果所需对象与预先配置的对象相同，那么只需克隆原型即可，无需新建一个对象。

现实生活中，产品在得到大规模生产前会使用原型进行各种测试。但在这种情况下，原型只是一种被动的工具，不参与任何真正生产活动。



## 结构

![image-20230219215325097](../../../../../blog/lucashelbyxx.github.io/images/image-20230219215325097.png)

1. 原型（Prototype）接口将对克隆方法进行声明。在绝大多数情况下，其中只会有一个名为 clone 的方法。
2. 具体原型（Concrete Prototype）类将实现克隆方法。除了将原始对象的数据复制到克隆体中之外，该方法有时还需处理克隆过程中的极端情况，例如克隆关联对象和梳理递归依赖等等。
3. 客户端（Client）可以复制实现了原型接口的任何对象。

![image-20230219215352299](../../../../../blog/lucashelbyxx.github.io/images/image-20230219215352299.png)

原生注册表（Prototype Registry）提供了一种访问常用原型的简单方法，其中存储了一系列可供随时复制的预生成对象。最简单的注册表原型是一个 名称 —> 原型 的哈希表。但如果需要使用名称以外的条件进行搜索，你可以创建更加完善的注册表版本。



## 伪代码

![image-20230219215736296](../../../../../blog/lucashelbyxx.github.io/images/image-20230219215736296.png)

在本例中，原型模式能让你生成完全相同的几何对象副本，同时无需代码与对象所属类耦合。

所有形状类都遵循同一个提供克隆方法的接口。在复制自身成员变量值到结果对象前，子类可调用其父类的克隆方法。

```
// 基础原型
abstract class shape is
	field X: int
	field Y: int
	field color: string
	
	// 常规构造函数
	constructor Shape() is
		// ...
		
	// 原型构造函数。使用已有对象的数值来初始化一个新对象
	constructor Shape() is
		this()
		this.X = source.X
		this.Y = source.Y
		this.color = source.color
	
	// clone (克隆) 操作会返回一个形状子类
	abstract method clone():Shape
	
// 具体原型。克隆方法会创建一个新对象并将其传递给构造函数。直到构造函数
// 运行完成前，它都拥有指向新克隆对象的引用。因此，任何人都无法访问未完全
// 生成的克隆对象。这可以保持克隆结果的一致。
class Rectangle extends Shape is
	field width: int
	field height: int
	
	constructor Rectangle(source: Rectangle) is
		// 需要调用父构造函数来复制父类中定义的私有成员变量
		super(source)
		this.width = source.width
		this.height = source.height
		
	method clone():Shape is
		return new Rectangle(this)
		
class Circle extends Shape is
	field radius: int
	
	constructor Circle(source: Circle) is
		super(source)
		this.radius = source.radius
		
	method clone():Shape is
		return new Circle(this)

// 客户端代码中的某个位置
class Application is
	field shapes: array of Shape
	
	constructor Application() is
		Circle circle = new Circle()
		circle.X = 10
		circle.Y = 10
		circle.radius = 20
		shapes.add(circle)
		
		Circle anotherCircle = circle.clone()
		shapes.add(anotherCircle)
		// 变量 'anotherCircle'与'circle'对象内容完全一样
		
		Rectangle rectangle = new Rectangle()
		rectangle.width = 10
		rectangle.height = 20
		shapes.add(rectangle)
		
	method businessLogic() is
		// 原型是很强大的东西，因为它能在不知晓对象类型的情况下生成一个与
		// 其完全相同的复制品
		Array shapesCopy = new Array of Shapes
		
		// 例如，我们不知晓形状数组中元素的具体类型，只知道它们都是形状。
		// 但在多态机制的帮助下，当我们在某个形状上调用 clone 方法时，
		// 程序会检查其所属的类并调用其中所定义的 clone 方法。这样，
		// 我们将获得一个正确的复制品，而不是一组简单的形状对象。
		foreach (s in shapes) do
			shapesCopy.add(s.clone())
			
		// shapesCopy 数组中包含 shape 数组所有子元素的复制品
```



## 适用场景

- 如果你需要复制一些对象，同时又希望代码独立于这些对象所属的具体类，可以使用原型模式。

  这一点的考量通常出现在代码需要处理第三方代码通过接口传递过来的对象时。即使不考虑代码耦合的情况，你的代码也不能依赖这些对象所属的具体类，因为你不知道它们的具体信息。

  原型模式为客户端代码提供了一个通用接口，客户端代码可通过这一接口与所有实现了克隆的对象进行交互，它也使得客户端代码与其所克隆的对象具体类独立开来。

- 如果子类的区别仅在于其对象的初始化方式，那么你可以使用该模式来减少子类的数量。别人创建这些子类的目的可能是为了创建特定类型的对象。

  在原型模式中，你可以使用一系列预生成的、各种类型的对象作为原型。客户端不必根据需求对子类进行实例化，只需找到合适的原型并对其进行克隆即可。



## 实现方式

1. 创建原型接口，并在其中声明 clone 方法。如果已有类层次结构，则只需在其所有类中添加该方法即可。

2. 原型类必须另行定义一个以该类对象为参数的构造函数。构造函数必须复制参数对象中的所有成员变量值到新建实体中。如果你需要修改子类，则必须调用父类构造函数，让父类复制其私有成员变量值。

   如果编程语言不支持方法重载，那么你可能需要定义一个特殊方法来复制对象数据。在构造函数中进行此类处理比较方便，因为它在调用 new 运算符后会马上返回结果对象。

3. 克隆方法通常只有一行代码：使用 new 调用原型版本的构造函数。注意，每个类都必须显式重写克隆方法并使用自身类名调用 new。否则，克隆方法可能会生成父类的对象。

4. 你还可以创建一个中心化原型注册表，用于存储常用原型。

   你可以新建一个工厂类来实现注册表，或者在原型基类中添加一个获取原型的静态方法。该方法必须能够根据客户端代码设定的条件进行搜索。搜索条件可以是简单的字符串，或者是一组复杂的搜索参数。找到合适的原型后，注册表应对原型进行克隆，并将复制生成的对象返回给客户端。最后还要将对子类构造函数的直接调用替换为对原型注册表工厂方法的调用。



## 优缺点

- 你可以克隆对象，而无需与它们所属的具体类相耦合
- 你可以克隆预生成原型，避免反复运行初始化代码
- 你可以更方便地生成复杂对象
- 你可以用继承以外的方式来处理复杂对象的不同配置
- 克隆包含循环引用的复杂对象可能会非常麻烦



## 与其他模式的关系

- 在许多设计工作的初期都会使用工厂方法模式，随后演化为使用抽象工厂模式、 原型模式或生成器模式。
- 抽象工厂模式通常基于一组工厂方法，但你也可以使用原型模式来生成这些类的方法。
- 原型可用于保存命令模式的历史记录
- 大量使用组合模式和装饰模式的设计通常可从对于原型的使用中获益。你可以通过该模式来复制复杂结构，而非从零开始重新构造。
- 原型并不基于继承，因此没有继承的缺点。另一方面，原型需要对被复制对象进行复杂的初始化。工厂方法基于继承，但是它不需要初始化步骤。
- 有时候原型可以作为备忘录模式的一个简化版本，其条件是你需要在历史记录中存储的对象的状态比较简单，不需要连接其他外部资源，或者链接可以方便地重建。
- 抽象工厂、生成器和原型都可以用单例模式来实现。



# **单例**

Singleton

让你能够保证一个类只有一个实例，并提供一个访问该实例的全局节点。



## 问题

单例模式同时解决了两个问题，所以违反了单一职责原则：

1. 保证一个类只有一个实例。为什么会想要控制一个类所拥有的实例数量？最常见的原因是控制某些共享资源（例如数据库或文件）的访问权限。

   运作方式：如果你创建了一个对象，同时过一会你决定在创建一个新对象，此时你会获得之前已创建的对象，而不是一个新对象。客户端甚至可能没有意识到它们一直都在使用同一个对象。注意：普通构造函数无法实现上述行为，因为构造函数的设计决定了它必须总是返回一个新对象。

2. 为该实例提供一个全局访问节点。还记得用过的那些存储重要对象的全局变量吗？它们在使用上十分方便，但同时也非常不安全，因为任何代码都有可能覆盖掉那些变量的内容，从而引发程序崩溃。

   和全局变量一样，单例模式也允许在程序的任何地方访问特定对象。但是它可以保护该实例不被其他代码覆盖。还有一点：你不会希望解决同一个问题的代码分散在程序各处的。因此更好的方式是将其放在同一个类中，特别是当其他代码已经依赖这个类时更应该如此。

   

## 解决方案

所有的单例实现都包含以下两个相同的步骤：

- 将默认构造函数设为私有，防止其他对象使用单例类的 new 运算符。
- 新建一个静态构造方法作为构造函数。该函数会调用私有构造函数来创建对象，并将其保存在一个静态成员变量中。此后所有对于该函数的调用都将返回这一缓存对象。

如果你的代码能够访问单例类，那它就能调用单例类的静态方法。无论何时调用该方法，它总是会返回相同的对象。



## 结构

![image-20230220212515588](../../../../../blog/lucashelbyxx.github.io/images/image-20230220212515588.png)

Singleton 类声明了一个名为 getInstance 的静态方法来返回其所属类的一个相同实例。单例的构造函数必须对 Client 代码隐藏。调用 getInstance 方法必须是获取单例对象的唯一方式。



## 伪代码

本例中，数据库连接类既是一个单例。该类不提供共有构造函数，因此获取该对象的唯一方式是调用 getInstance 方法。该方法将缓存首次生成的对象，并未所有后续调用返回该对象。

```
// 数据库类会对 getInstance 方法进行定义以让客户端在程序各处
// 都能访问相同的数据库连接实例
public Database is
	// 保存单例实例的成员变量必须被声明为静态类型
	private static field instance: Database
	
	// 单例的构造函数必须是私有类型，防止使用 new 直接调用构造方法
	private constructor Database() is
		// 部分初始化代码（例如到数据库服务器的实际连接）
		// ...
	
	// 用于实际对单例实例的访问权限的静态方法
	public static method getInstance() is
		if (Database.instance == null) then
			acquireThreadLock() and then
				// 确保在该线程等待解锁时，其他线程没有初始化该实例
				if (Database.instance == null) then
					Database.instance = new Database()
		return Database.instance
	
	// 最后，任何单例都必须定义一些可在其实例上执行的业务逻辑
	public method query(sql) is
		// 比如应用的所有数据库查询请求都需要通过该方法进行。
		// 因此，可以在这里添加限流或缓冲逻辑...
	
class Application is
	method main() is
		Database foo = Database.getInstance()
		foo.query("SELECT ...")
		// ...
		Database bar = Database.getInstance()
		bar.query("SELECT ...")
		// 变量 bar 和 foo 中将包含同一个对象
```



## 适用场景

- 如果程序中的某个类对于所有客户端只有一个可用的实例，可以使用单例模式

  单例模式禁止通过除特殊构建方法以外的任何方式来创建自身类的对象。该方法可以创建一个新对象，但如果该对象已经被创建，则返回已有的对象。

- 如果需要更加严格地控制全局变量，可以使用单例模式

  单例模式与全局变量不同，它保证类只存在一个实例。除了单例类自己以外，无法通过任何方式替换缓存的实例。你可以随时调整限制并设定生成单例实例的数量，只需修改 getInstance 方法。



## 实现方式

1. 在类中添加一个私有静态成员变量用于保存单例实例。
2. 声明一个公有静态构造方法用于获取单例实例。
3. 在静态方法中实现 “延迟初始化”。该方法会在首次被调用时创建一个新对象，并将其存储在静态成员变量中。此后该方法每次被调用时都返回该实例。
4. 该类的构造函数设为私有。类的静态方法仍能调用构造函数，但是其他对象不能调用。
5. 检查客户端代码，将对单例的构造函数的调用替换为对其静态构建方法的调用。



## 优缺点

- 你可以保证一个类只有一个实例。
- 你获得了一个指向该实例的全局访问节点。
- 仅在首次请求单例对象时对其进行初始化。
- 违反单一职责原则，该模式同时解决了两个问题。
- 单例模式可能掩盖不良设计，比如程序各组件之间相互了解过多等。
- 该模式在多线程环境下需要进行特殊处理，避免多个线程多次创建单例对象。
- 单例的客户端代码单元测试可能会比较困难，因为许多测试框架已基于继承的方式创建模拟对象。由于单例类的构造函数是私有的，而且绝大部分语言无法重写静态方法，所以你需要想出仔细考虑模拟单例的方法。要么干脆不写测试代码，或者不使用单例模式。



## 与其他模式的关系

- 外观模式类通常可以转换为单例模式类，因为在大部分情况下一个外观对象足够了。
- 如果你能将对象的所有共享状态简化为一个享元对象，那么享元模式和单例类似了。但这两个模式有两个根本性的不同。
  1. 只会有一个单例实体，但是享元类可以有多个实体，各实体的内在状态也可以不同。
  2. 单例对象可以是可变的。享元对象是不可变的。
- 抽象工厂、生成器和原型都可以用单例来实现。

