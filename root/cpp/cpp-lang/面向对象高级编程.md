重学 C++



# C++ 编程简介



# 头文件与类的声明

C, C++ 关于数据与函数

函数就是用来处理数据的。在 C 中没有足够的关键字，这些数据一定是全局的，各个函数都可以处理它们。

后来发展出面向对象语言。C++ 把数据和处理这些数据的函数包在一起（Class），这些数据只有这些方法可以处理，其他人看不到。C++ 的 struct 几乎等同于 class。



最经典的 class 分类，一种是带有指针的，一种是里头不带指针的。这会影响后面的写法，影响深远。

```c++
// Object Based(基于对象)：面对的是单一 class 的设计
// Class with pointer member(s)
complex
field 实部，虚部  --create-->  c1,c2,c3,c4...

function 加减乘除，共轭，正弦...


// Object Oriented(面向对象)：面对的是多重 classes 的设计，
// classes 和classes 之间的关系
// Class without pointer member(s)
string
字符(s)	--create-->	s1,s2,s3,s4...
//其实是一个 ptr，指向一串字符

function 拷贝，输出，附加，插入...


// 创建对象
complex c1(2,1);
complex c2;
complex* pc = new complex(0,1);

string s1("Hello ");
string s2("World ");
string* ps = new string;
```

数据可以有很多份，但函数只有一份。中间桥梁？



C++ programs 代码基本形式

```
.h (header files)
Classes Declaration

+

.cpp
#include <iostream.h>
#include "complex.h"

	ex.main()

+

.h (header files)
Standard Library
```

extension file name 不一定是 .h 或 .cpp（在不同平台上可能不一样），也可能是 .hpp 或其他或甚至无延伸名。



Output，C++ vs. C

```cpp
// C++
#include <iostream.h>	// or #include <iostream>
using namespace std;

int main() {
	int i = 7;
	cout << "i=" << i << endl;
	
	return 0;
}


// C
#include <stdio.h>	// or #include <cstdio>

int main() {
	int i = 7;
	printf("i=%d \n", i);
	
	return 0;
}
```



Header（头文件）中的防卫式声明、布局

```cpp
// complex.h
#ifndef _COMPLEX_	// guard(防卫式声明)
#define _COMPLEX_

// ...主体
#include <cmath>

class ostream;	// forward declarations（前置声明）
class complex;

complex&
	_doapl (complex* ths, const complex& r);
	
class complex {	// class declarations（类-声明）
	...
};

complex::function ...	// class definition（类-定义）

#endif
```

因为很多程序都要用到这个头文件，include 含入的次序如果要求是特定的，对使用者负担太沉重了。

程序第一次 include 时定义这个 COMPLEX，会进入这个主体。第二次 COMPLEX 定义过了，就不会进入这个主体。



class 的声明（declaration）

```cpp
class complex	// class head
{	// class body
	// 这里面就要开始设计我的复数应该具备什么样的数据,
	//怎么样的函数才能满足使用者的需求
public:
	complex (double r = 0, double i = 0) : re (r), im (i)
	{ }
	complex& operator += (const complex&);
	double real () const { return re; }	// 有些函数在此直接定义，另一些在 body 之外定义
	double imag () const { return im; }
private:
	double re, im;	// 不同类型需要定义好几个类
	
    // 设计另外一个函数，它和它之间是朋友关系
	friend complex& _doapl (complex*, const complex&);
};

{
	complex c1(2,1);
	complex c2;
	...
}
```



class template（模板）简介

```cpp
// 实部虚部的类型不要现在就写死，等到使用时再绑定、指定
template<typename T>
class complex
{
public:
	complex (T r = 0, T i = 0) : re (r), im (i)
	{ }
	complex& operator += (const complex&);
	double real () const { return re; }	
	double imag () const { return im; }
private:
	T re, im;
	
	friend complex& _doapl (complex*, const complex&);
};


{
	complex<double> c1(2.5,1.5);
	complex<int> c2(2,6);
	...
}
```

 



# 构造函数

# 参数传递与返回值

# 操作符重载与临时对象

# Complex 类的实现过程

# 三大函数：拷贝构造，拷贝复制，析构

# 堆、栈与内存管理

# String 类的实现过程

# 扩展：类模板，函数模板，及其他

# 组合与继承

# 虚函数与多态

# 委托相关设计



导读

conversion function

non-explicit one argument constructor

pointer-like classes

function-like classes

namespace经验谈

class template

function template

member template

specialization

模板偏特化

模板参数

关于 C++ 标准库

三个主题

reference

符合&继承关系下的构造和析构

关于 vptr 和 vtbl

关于 Dynamic Binding

关于 this

关于 new， delete

operator new, operator delete

示例

重载 new(), delete()

basic_string 使用new(extra)扩充申请量