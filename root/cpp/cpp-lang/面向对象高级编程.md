# 重学 C++



# C++ 编程简介



# 头文件与类的声明

C, C++ 关于数据与函数

函数就是用来处理数据的。在 C 中没有足够的关键字，这些数据一定是全局的，各个函数都可以处理它们。

后来发展出面向对象语言。C++ 把数据和处理这些数据的函数包在一起（Class），这些数据只有这些方法可以处理，其他人看不到。C++ 的 struct 几乎等同于 class。



最经典的 class 分类，一种是带有指针的，一种是里头不带指针的。这会影响后面的写法，影响深远。

```c++
// Object Based(基于对象)：面对的是单一 class 的设计
// Class with pointer member(s)
complex
field 实部，虚部  --create-->  c1,c2,c3,c4...

function 加减乘除，共轭，正弦...


// Object Oriented(面向对象)：面对的是多重 classes 的设计，
// classes 和classes 之间的关系
// Class without pointer member(s)
string
字符(s)	--create-->	s1,s2,s3,s4...
//其实是一个 ptr，指向一串字符

function 拷贝，输出，附加，插入...


// 创建对象
complex c1(2,1);
complex c2;
complex* pc = new complex(0,1);

string s1("Hello ");
string s2("World ");
string* ps = new string;
```

数据可以有很多份，但函数只有一份。中间桥梁？



C++ programs 代码基本形式

```
.h (header files)
Classes Declaration

+

.cpp
#include <iostream.h>
#include "complex.h"

	ex.main()

+

.h (header files)
Standard Library
```

extension file name 不一定是 .h 或 .cpp（在不同平台上可能不一样），也可能是 .hpp 或其他或甚至无延伸名。



Output，C++ vs. C

```cpp
// C++
#include <iostream.h>	// or #include <iostream>
using namespace std;

int main() {
	int i = 7;
	cout << "i=" << i << endl;
	
	return 0;
}


// C
#include <stdio.h>	// or #include <cstdio>

int main() {
	int i = 7;
	printf("i=%d \n", i);
	
	return 0;
}
```



Header（头文件）中的防卫式声明、布局

```cpp
// complex.h
#ifndef _COMPLEX_	// guard(防卫式声明)
#define _COMPLEX_

// ...主体
#include <cmath>

class ostream;	// forward declarations（前置声明）
class complex;

complex&
	_doapl (complex* ths, const complex& r);
	
class complex {	// class declarations（类-声明）
	...
};

complex::function ...	// class definition（类-定义）

#endif
```

因为很多程序都要用到这个头文件，include 含入的次序如果要求是特定的，对使用者负担太沉重了。

程序第一次 include 时定义这个 COMPLEX，会进入这个主体。第二次 COMPLEX 定义过了，就不会进入这个主体。



class 的声明（declaration）

```cpp
class complex	// class head
{	// class body
	// 这里面就要开始设计我的复数应该具备什么样的数据,
	//怎么样的函数才能满足使用者的需求
public:
	complex (double r = 0, double i = 0) : re (r), im (i)
	{ }
	complex& operator += (const complex&);	// 这里没有大括号，只是声明而已
	double real () const { return re; }	// 有些函数在此直接定义，另一些在 body 之外定义
	double imag () const { return im; }
private:
	double re, im;	// 不同类型需要定义好几个类
	
    // 设计另外一个函数，它和它之间是朋友关系
	friend complex& _doapl (complex*, const complex&);
};

{
	complex c1(2,1);
	complex c2;
	...
}
```



class template（模板）简介

```cpp
// 实部虚部的类型不要现在就写死，等到使用时再绑定、指定
template<typename T>
class complex
{
public:
	complex (T r = 0, T i = 0) : re (r), im (i)
	{ }
	complex& operator += (const complex&);
	double real () const { return re; }	
	double imag () const { return im; }
private:
	T re, im;
	
	friend complex& _doapl (complex*, const complex&);
};


{
	complex<double> c1(2.5,1.5);
	complex<int> c2(2,6);
	...
}
```

 



# 构造函数

inline（内联）函数

```cpp
class complex	// class head
{
public:
	complex (double r = 0, double i = 0) : re (r), im (i)
	{ }
	complex& operator += (const complex&);	
	double real () const { return re; }	// 函数若在 class body 内定义完成，
	double imag () const { return im; }	// 便自动成为 inline 候选人
private:
	double re, im;	
	
	friend complex& _doapl (complex*, const complex&);
};


inline double	// 不在 body 定义，告诉编译器尽量把我看做 inline，由编译器决定
imag(const complex& x)
{
    return x.imag();
}
```

[C++ inline和#define宏的区别 - wywdahai - 博客园 (cnblogs.com)](https://www.cnblogs.com/yanwei-wang/p/8073111.html)

如果你的函数是 inline function 会比较快、好。但是有些 function （太复杂）你说是  inline，编译器也不会当做 inline。你的 inline 只是对编译器的建议而已，是否真正的 inline 由编译器决定。



access level（访问级别）

```cpp
class complex	// class head
{
public:
	complex (double r = 0, double i = 0) : re (r), im (i)
	{ }
	complex& operator += (const complex&);	
	double real () const { return re; }	// 函数若在 class body 内定义完成，
	double imag () const { return im; }	// 便自动成为 inline 候选人
private:
	double re, im;	
	
	friend complex& _doapl (complex*, const complex&);
};


// XXX
{
    complex c1(2,1);
    cout << c1.re;
    cout << c1,im;
}


// OOO
{
    complex c1(2,1);
    cout << c1.real();
    cout << c1.imag();
}
```

body 之中可以区分为某几大段，用 public、private 关键字来区分，第三种 protected。

数据部分放 private，因为数据是要封装起来的，不要被外界任意看到，应该只有自己类才可以看到。数据一定要通过自己的函数传递出去或者被设定，一个读一个写。不能够直接外部去拿。除非这些数据是 public，但这是我们要避免的事情。

函数部分可以分为两部分：一部分是给外界用的，一部分是处理自己的私人事情的。这些段落可以任意交错出现。



constuctor（ctor，构造函数）

```cpp
class complex
{
public:
	complex (double r = 0, double i = 0) 	// default argument(默认实参)
        : re (r), im (i)	// 1、初始化，initialization list(初值列，初始列)
	{ /* 2、赋值 */ }
    
    // 这样写，相当于放弃了初始化阶段。虽然你还是把值放进去了，但时间点已经晚了，效率差了
    /* assignment (赋值)	? XXX
    complex (double r = 0, double i = 0) 
    { re = r, im =i; }
    */
    
	complex& operator += (const complex&);	
	double real () const { return re; }
	double imag () const { return im; }
private:
	double re, im;	
	
	friend complex& _doapl (complex*, const complex&);
};


{
    complex c1(2,1);	// 1、创建实部为2，虚部为1的对象
    complex c2;		// 2、创建没有指明参数的对象，使用默认参数
    complex* p = new complex(4);	// 3、以动态的方式来创建一个对象，得到的是一个指针
    ...
}
```

C++ 语言说你想要创建一个对象，有一个函数会被自动调用起来，叫构造函数。构造函数的写法很独特，其名称一定要跟类名称相同，它可以拥有参数，参数是可以有默认值的。其他函数也可以写出默认值来。

构造函数没有返回类型，不需要。构造函数就是来创建对象的，不能改变的，没必要写。

构造函数有一个特别写法，其他函数没有的，initialization list。一个变量数值的设定有两阶段，第一个阶段就是初始化，第二个阶段是赋值







# 参数传递与返回值

# 操作符重载与临时对象

# Complex 类的实现过程

# 三大函数：拷贝构造，拷贝复制，析构

# 堆、栈与内存管理

# String 类的实现过程

# 扩展：类模板，函数模板，及其他

# 组合与继承

# 虚函数与多态

# 委托相关设计



导读

conversion function

non-explicit one argument constructor

pointer-like classes

function-like classes

namespace经验谈

class template

function template

member template

specialization

模板偏特化

模板参数

关于 C++ 标准库

三个主题

reference

符合&继承关系下的构造和析构

关于 vptr 和 vtbl

关于 Dynamic Binding

关于 this

关于 new， delete

operator new, operator delete

示例

重载 new(), delete()

basic_string 使用new(extra)扩充申请量