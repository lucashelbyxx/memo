# 1、概述

图书大抵分两类：学习和研究。学习类书籍满足日常学习和提升需要，用简练的语言把问题说清楚。最关键的是有清晰的线索，把散乱的知识串联起来，学习者可据此了解前因后果。至于研究类图书或论文，则应摆脱基础，摆脱语法，重点关注算法、架构、性能，乃至内部实现。所有这些，均以思想为支撑，超脱语言窠臼，构建并完善体系。		

不同于写散文或小说，技术类图书的文字不好组织。自然语言易阅读，但不便描述有复杂流程分支的逻辑，易导致歧义。更何况，这其中还有各种转译带来的麻烦。故技术类图书应以自然语言开宗明义，阐述理论与规则，随后用代码对这段文字进行解释，毕竟代码先天有描述逻辑的优势

很多书，尤其是英文版的图书，习惯于用大量篇幅对代码示例做各种讲解。我感觉这有些啰唆，想必很少有人去读第二遍，大家最多也就是用记号笔画出重点而已。既然如此，我们为何不信读者能阅读并理解这些代码呢？这本来就是程序员吃饭的本钱，最多在关键位置辅以注释便可。当然，阅读前提怕是要设定为非入门读者。好在我一再强调自己写的是第二本书，或曰“闲书”。

在本书中，对于理论层面，我会尝试说得明白些。当然，书中还会引入一些类比，这些类比或许不是非常合适，但却可以加深读者对相关问题的理解，毕竟不是所有人都能明白那些云里雾里的抽象理念。一如上面所言，文字与代码相辅相成，我们应静下心来用代码去验证文字背后的含义。在我眼里，代码也是一种自然语言，缩排跳转仿若图 形，本就是最好的笔记注释。起码它离机器语言上有些距离，是为了便于人类阅读而发明的。

——python 3学习笔记



# 2、类型

## 2.1 基本环境

### 印象

### 名字

名字

名字空间

### 内存

弱引用

弱引用可用于一些特定场合，比如缓存、监控等。这类“外挂”场景不应该影响目标对 象，不能阻止它们被回收。弱引用的另一个典型应用是实现 Finalizer，也就是在对象被回收时执行额外的“清理”操作。



对象复制

值传递、引用传递

在调用函数时，我们或许仅仅是想传递一个状态，而非整个实体。

### 编译

### 执行



## 2.2 内置类型

### 整数

### 浮点数

### 字符串

Unicode 的设计意图是为了解决跨语言、跨平台转换和处理需求，其用统一编码方案容纳不 同国家地区的文字，以解决传统编码方案的不兼容问题，故又称作统一码、万国码。 

Unicode 为每个字符分配一个被称作码点（code point）的整数序号，对应的编码方案叫作通 用字符集（Universal Character Set, UCS）。依编码整数长度，其又分为 UCS-2 和 UCS-4 两种， 后者为 32 位，可容纳更多字符。UCS 只规定了字符和码点的对应关系，并不涉及如何显示 和存储。 

UTF（Unicode Transformation Format）的作用是将码点整数转换为计算机可存储的字节格式。 发展至今，有 UTF-8、UTF-16、UTF-32 等多种方案。其中 UTF-8 采用变长格式，因其与 ASCII 兼容，故此是当下使用最广泛的一种。对于以英文为主的内容，UTF-8 可获得最好的 存储效率。而使用两字节等长方案的 UTF-16，有更快的处理效率，常被用作执行编码。



相比于多次加法运算和多次内存分配（字符串是不可变对象），join 这类函数（方法）可预先 计算出总长度，一次性分配内存，随后直接复制内存数据填充。另一方面，将固定模板内容 与变量分离的 format，更易阅读和维护。

```python
>>> tmpl = "/data/{user}/message/{time}.txt" # 模板单独维护
>>> tmpl.format(user = username, time = datetime) # 无须考虑参数的次序
/data/qyuhen/message/20170101.txt
```



使用两个索引号表示一个序列片段的语法被称作切片（slice），可以此返回字符串子串。 无论以哪种方式返回与原字符串内容不同的子串时，都可能会重新分配内存，并复制数据。



池化 

字符串可能是进程里实例数量最多的类型之一，因为无处不在的名字就是字符串实例。 鉴于相同名字会重复出现在不同的名字空间里，那么有必要共享实例。内容相同，且不可变，共享不会导致任何问题。关键是节约内存，且可省去创建新实例的开销。

对此，Python 的做法是实现一个字符串池（intern）。 池负责管理实例，使用者只需引用即可。另一潜在的好处是，从池返回的字符串，只需比较 指针就可知道内容是否相同，无须额外计算。可以用池来提升哈希表等类似结构的查找性能。

除以常量方式出现的名字和字面量外，动态生成的字符串一样可加入池中。如此可保证 每次都引用同一对象，不会有额外的创建和分配操作。

当然，一旦失去所有外部引用，池内的字符串对象一样会被回收。

做大数据处理时，可能须创建海量主键，使用类似机制有助于减少对象数量，节约大量内存。 当然，可以选择更高效的数据结构，而不一定是系统内置的字符串池。



### 字节数组

虽然生物都由细胞构成，但在普通人的眼里，并不会将人、狮子、花草这些当作细胞看待。因为对待事物的角度决定了，我们更关心生物的外在形状和行为，而不是其组织构成。 从底层实现来说，所有数据都是二进制字节序列。但为了更好地表达某个逻辑，我们将 其抽象成不同类型，一如细胞和狮子的关系。当谈及字节序列时，我们更关心的是存储和传输方式；而面向类型时，则着重于其抽象属性。尽管一体两面，但从不混为一谈。



内存视图

如果要引用字节数据的某个片段，该怎么做？需要考虑的问题如下：是否会有数据复制行为？是否能同步修改？

为什么需要引用某个片段，而不是整个对象？ 以自定义网络协议为例，通常由标准头和数据体两部分组成。如要验证数据是否被修改，总 不能将整个包作为参数交给验证函数。这势必要求该函数了解协议包结构，这显然是不合理的设计。而复制数据体又可能导致重大性能开销，同样得不偿失。

鉴于 Python 没有指针概念，外加内存安全模型的限制，要做到这一点似乎并不容易。因此，须借助一种名为内存视图（Memory Views）的方式来访问底层内存数据。

内存视图要求目标对象支持缓冲协议（Buffer Protocol）。它直接引用目标内存，没有额外复制行为。因此，可读取最新数据。在目标对象允许的情况下，还可执行写操作。

### 列表

不同于数组，列表仅存储指针，而对元素内容并不关心，故可以是不同类型混合。

但在操作方式上，元组可被当作列表的只读版本使用。

数组与列表、元组的本质区别在于：元素单一类型和内容嵌入。

由于可指定更紧凑的数字类型，故数组可节约更多内存。再者，内容嵌入也避免了对象的额外开销，减少了活跃对象的数量和内存分配的次数。

### 字典

字典是内置类型中唯一的映射（mapping）结构，基于哈希表存储键值对数据。 值可以是任意数据，但主键必须是可哈希类型。常见的可变类型，如列表、集合等都不能作为主键使用。即便是元组等不可变类型，也不能引用可变类型元素。



视图 

与早期版本复制数据并返回列表不同，Python 3 默认以视图关联字典内容。如此一来， 既能避免复制开销，还能同步观察字典变化。



字典没有独立的只读版本，无论传递引用还是复制品，都存在弊端。直接引用有被接收方修改内容的风险，而复制品又仅是一次性快照，无法获知字典变化。视图则不同，它能同步读取字典内容，却无法修改。且可选择不同粒度的内容进行传递，如此可将接收方限定为指定模式下的观察员。



### 集合

集合作为初等数学概念，其重点自然是并差集运算。合理使用这些操作，可简化算法筛 选逻辑，使其具备更好的可读性。



# 3、表达式

## 词法

### 源文件

### 代码

## 赋值

增量赋值 
增量赋值试图直接修改原对象内容，实现累加效果。当然，其前提是目标对象允许，否则会退化为普通赋值。既然是增量，就须确保目标对象已存在。

序列解包 
不同于将多个名字关联到单一对象，序列解包展开所有元素，继而分别与多个名字关联。


### 增量赋值

### 序列解包

### 作用域

## 运算符

### 链式比较

### 切片

### 逻辑运算

## 控制流

### 选择

### 循环

## 推导式



# 4、函数

定义

函数是代码复用和模块化的基本单位，用于执行单一逻辑。

函数应减少依赖关系，具备良好的可测试性和可维护性，这是性能优化的关键所在。另 外，我们还应遵循一个基本原则，就是专注于做一件事，不受外在干扰和污染。



创建

函数由两部分组成：代码对象持有字节码和指令元数据，负责执行；函数对象则为上下 文提供调用实例，并管理所需的状态数据。

代码对象的相关属性由编译器生成，为只读模式。存储指令运行所需的相关信息，诸如 源码行、指令操作数，以及参数和变量名等。

事实上，def 是运行期指令。以代码对象为参数，创建函数实例，并在当前上下文中与指定的名字相关联。



## 参数

## 返回值

## 作用域

## 闭包

## 调用



# 5、迭代器

## 迭代器概述

## 生成器

## 模式

## 函数式编程



# 6、模块

## 定义

## 导入

### 搜索

### 编译

### 引用

## 包

### 初始化

### 相对导入

### 拆分



# 7、类

## 定义

## 字段

## 属性

## 方法

## 继承

### 统一类型

### 初始化

### 覆盖

### 多继承

### 抽象类

## 开放类

## 运算符重载



# 8、异常

## 异常概述

## 断言

## 上下文



# 9、元编程

## 装饰器

### 实现

### 应用

## 描述符

## 元类

### 自定义

### 应用

## 注解



# 10、进阶

## 解释器

### 字节码

### 全局锁

### 执行过程

### 内存分配

### 垃圾回收

## 扩展

### ctypes

### Cython



# 11、测试

## 单元测试

### unittest

### unittest.mock

### coverage

## 性能测试

### timeit

### profile

### line profiler

### memory profiler

### pympler



# 12、工具

## 调试器

## 包管理