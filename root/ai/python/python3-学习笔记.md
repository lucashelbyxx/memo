# 1、概述

图书大抵分两类：学习和研究。学习类书籍满足日常学习和提升需要，用简练的语言把问题说清楚。最关键的是有清晰的线索，把散乱的知识串联起来，学习者可据此了解前因后果。至于研究类图书或论文，则应摆脱基础，摆脱语法，重点关注算法、架构、性能，乃至内部实现。所有这些，均以思想为支撑，超脱语言窠臼，构建并完善体系。		

不同于写散文或小说，技术类图书的文字不好组织。自然语言易阅读，但不便描述有复杂流程分支的逻辑，易导致歧义。更何况，这其中还有各种转译带来的麻烦。故技术类图书应以自然语言开宗明义，阐述理论与规则，随后用代码对这段文字进行解释，毕竟代码先天有描述逻辑的优势

很多书，尤其是英文版的图书，习惯于用大量篇幅对代码示例做各种讲解。我感觉这有些啰唆，想必很少有人去读第二遍，大家最多也就是用记号笔画出重点而已。既然如此，我们为何不信读者能阅读并理解这些代码呢？这本来就是程序员吃饭的本钱，最多在关键位置辅以注释便可。当然，阅读前提怕是要设定为非入门读者。好在我一再强调自己写的是第二本书，或曰“闲书”。

在本书中，对于理论层面，我会尝试说得明白些。当然，书中还会引入一些类比，这些类比或许不是非常合适，但却可以加深读者对相关问题的理解，毕竟不是所有人都能明白那些云里雾里的抽象理念。一如上面所言，文字与代码相辅相成，我们应静下心来用代码去验证文字背后的含义。在我眼里，代码也是一种自然语言，缩排跳转仿若图 形，本就是最好的笔记注释。起码它离机器语言上有些距离，是为了便于人类阅读而发明的。

——python 3学习笔记



# 2、类型

## 2.1 基本环境

### 印象

### 名字

名字

名字空间

### 内存

弱引用

弱引用可用于一些特定场合，比如缓存、监控等。这类“外挂”场景不应该影响目标对 象，不能阻止它们被回收。弱引用的另一个典型应用是实现 Finalizer，也就是在对象被回收时执行额外的“清理”操作。



对象复制

值传递、引用传递

在调用函数时，我们或许仅仅是想传递一个状态，而非整个实体。

### 编译

### 执行

## 2.2 内置类型

### 整数

### 浮点数

### 字符串

### 字节数组

### 列表

### 字典

### 集合



# 3、表达式

## 词法

### 源文件

### 代码

## 赋值

### 增量赋值

### 序列解包

### 作用域

## 运算符

### 链式比较

### 切片

### 逻辑运算

## 控制流

### 选择

### 循环

## 推导式



# 4、函数

## 定义

## 参数

## 返回值

## 作用域

## 闭包

## 调用



# 5、迭代器

## 迭代器概述

## 生成器

## 模式

## 函数式编程



# 6、模块

## 定义

## 导入

### 搜索

### 编译

### 引用

## 包

### 初始化

### 相对导入

### 拆分



# 7、类

## 定义

## 字段

## 属性

## 方法

## 继承

### 统一类型

### 初始化

### 覆盖

### 多继承

### 抽象类

## 开放类

## 运算符重载



# 8、异常

## 异常概述

## 断言

## 上下文



# 9、元编程

## 装饰器

### 实现

### 应用

## 描述符

## 元类

### 自定义

### 应用

## 注解



# 10、进阶

## 解释器

### 字节码

### 全局锁

### 执行过程

### 内存分配

### 垃圾回收

## 扩展

### ctypes

### Cython



# 11、测试

## 单元测试

### unittest

### unittest.mock

### coverage

## 性能测试

### timeit

### profile

### line profiler

### memory profiler

### pympler



# 12、工具

## 调试器

## 包管理