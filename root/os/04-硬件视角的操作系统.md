# 计算机硬件

## 计算机硬件 = 数字电路

数字电路模拟器（Logisim）

- 基本构件：write, reg, NAND
- 每一个时钟周期
  - 先计算 write 的值
  - 在周期结束时把值锁存至 reg

“模拟” 的意义

- 程序是 “严格的数学对象”
- 实现模拟器意味着 “完全掌握系统行为”



冷启动：从没有电的状态，加电启动

热启动：CPU 已经在执行指令了，状态机已经在运行了，把状态机的状态复位到初始状态



## 计算机硬件的状态机模型

不仅是程序，整个计算机系统也是一个状态机

- 状态：内存和寄存器数值
- 初始状态：手册规定（CPU Reset）
- 状态迁移
  - 任意选择一个处理器 cpu
  - 响应处理器外部中断
  - 从 cpu.PC 取指令执行

到底谁定义了状态机的行为？

- 我们如何控制 “什么程序运行”



# 硬件与程序员的约定

qemu：A generic and open source machine emulator and virtualizer



gdb 重复调试 init.gdb(hook-quit)、makefile



watch point 知道内存是谁改的





# 实现最小 “操作系统”

## 我们已经获得的能力

为硬件直接编程

- 可以让机器运行任意不超过510字节的指令序列
- 编写任何指令序列（状态机）
  - 只要能问出问题，就可以 RTFM / STFW / ChatGPT 找到答案
    - “如何在汇编里生成 n 个字节的0“
    - ”如何在 x86 16-bit mode 打印字符“



操作系统：就一个 C 程序

- 用510字节的指令完成磁盘 -> 内存的加载
- 初始化 C 程序的执行环境
- 操作系统开始运行



## 实现操作系统 “心里没底”

大学的意义

- 迅速消化数十年来建立起的学科体系
  - 将已有的思想和方法重新组织，为大家建立好 ”台阶“
- 破除 “写操作系统很难”、“写操作系统很牛” 类似的错误认识
  - 操作系统真的就是个 C 程序
  - 你只是需要 “被正确告知” 一些额外的知识
    - 然后写代码、踩坑
    - 从而建立正确的 “专业世界观”



## Bare-mental 上的 C 代码

为了让下列程序能够运行起来：

```cpp
int main() {
    printf("Hello, World\n");
}
```

我们需要准备什么？

- MBR 上的启动加载器（Boot Loader）
- 我们可以通过编译器控制 C 程序的行为
  - 静态连接 / PIC（位置无关代码）
  - Freestanding（不使用任何标准库）
  - 自己手工实现库函数（putch, printf, ...）



## 进入细节的海洋

好消息：我们提供了运行 C 程序的框架代码和库

坏消息：框架代码也太复杂了吧

- 被 ICS PA 支配的恐惧
  - 读懂 Makefile 需要 STFW，RTFM，大量的经历
  - 读了很久都没读到重要的地方 -> 本能地放弃

花一点时间想 “有更好的办法吗？”

- 花几分钟创建一个小工具：“构建理解工具”
  - UNIX Philosophy
  - 把复杂的构建过程分解成流程 + 可理解的单点
- Get out of your comfort zone



（1）生成镜像和启动虚拟机

观察 AbstractMachine 程序编译过程的正确方法：

```
make -nB \
	| grep -ve '^\(\#\|echo\|mkdir\|make\)' \
	| sed "s#$AM_HOME#\$AM_HOME#g" \
	| sed "s#&PWD#.#g" \
	| vim -
```

- Command line tricks
  - make -nB
  - grep: 文本过滤，省略干扰项
    - echo（提示信息），mkdir（目录建立），make（sub-goals）
  - sed: 让输出更易读
    - 将绝对路径更换成相对路径



（2）改进文本可读性

想要看更清楚些？

- %s/  /\r  /g
  - 每一个命令就像一句话
  - AI

编译 / 链接

- -std=gnull, -m64, -mno-see, -I, -D, ...
  - 它们是导致 vscode 里红线的原因
- -melf_x86_64, -N, -Ttext-segment=0x00100000
  - 链接了需要的库



# Take-away Messages

计算机系统是严格的数学对象：没有魔法；计算机系统的一切行为都是可观测、可理解的。

- 处理器是无情的执行指令的机器
- 厂商配置好处理器 Reset 后的行为：先运行 Firmware，再加载操作系统
- 厂商逐渐形成了达成共识的 Firmware Specification (IBM PC “兼容机”、UEFI、……)
- 操作系统真的就是个 C 程序，只是能直接访问计算机硬件